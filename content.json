{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/blog/uncategorized/hello-world/"},{"title":"Apollo之GraphQL订阅","text":"GraphQL 的操作类型除了query, mutation外，还有订阅 subscription！ GraphQL 订阅是一种将数据从服务器推送到选择侦听服务器实时消息的客户端的方式。订阅需要服务器端的支持，在这里只讨论Apollo Client端的配置与使用；","link":"/blog/uncategorized/apollo%E4%B9%8Bgraphql%E8%AE%A2%E9%98%85/"},{"title":"Lit学习之路","text":"开篇首先介始一下web components的背景：组件化已经成为目前主流的前端开发方式，但是我们实现组件化主要依托于vue, angular, react等市面上流行的前端框架，这些框架在遵循W3C的规则下也有一套自己的开发规则和书写语法，官方也推出一套组件化的解决方案和原生API的支持——web components。 优势： 可以直接当做原生标签，在任何前端框架和无框架中运行。 CSS 隔离 Shadow DOM 中定义的 CSS 样式只在 ShadowRoot 下生效。这意味着样式被封装了起来。 浏览器原生支持的组件化实现 Web components 原生对css 的隔离性，从另外一个角度来说也是它的缺点之一。web components开发的组件，在使用时不可避免地需要改变它的内部样式，我认为有两种方法可以有效地达到效果： css变量 ::part伪元素 其中，&lt;slot&gt;元素作为占位元素，具体的内容显示是在父元素中的子元素决定的，它的样式有哪些方法可以改变呢？ 123456789&lt;my-element&gt; &lt;span&gt;子元素&lt;/span&gt;&lt;/my-element&gt;&lt;template&gt; &lt;p&gt;Welcome to the web components tutorial!&lt;/p&gt; &lt;p&gt;This is the custom code.&lt;/p&gt; &lt;slot part=&quot;slot&quot;&gt;this is slot&lt;/slot&gt;&lt;/template&gt; 12345678/* 直接设置子元素的样式 */my-element &gt; span { color: blue;}/* 使用::part设置slot元素的样式，&lt;span&gt;元素作为&lt;slot&gt;的子元素，继承其样式 */zxx-info::part(slot) { border-bottom: 1px dashed;} 在使用原生的web components写ui时，会有一种回到原生 JS 写应用的时代，特别是写事件回调时，需要在custom element 内部自定义事件 new CustomEvent()，外部用 addEventListener监听。这可能会让习惯使用了vue，react等框架的开发同学不太适应，因些采用原生web components 与 Lit 对比的方法，介绍web components 的简单用法； Web components库——LitLit 组件是可重用的UI片段。您可以将 Lit 组件视为具有某种状态并根据其状态显示 UI 的容器。它还可以对用户输入、触发事件做出反应——任何你希望UI组件做的事情。Lit 组件是一个HTML元素，因此它具有所有标准元素API。 创建一个Lit 组件涉及以下几个概念： Defining a component. Lit 组件作为自定义元素实现，并在浏览器中注册。 Rending. 组件包含 render 方法，用来渲染组件的内容。在render方法中，您为组件定义了一个模板(类似于jsx的语法)。 Reactive properties. 属性保存组件的状态。改变组件的一个或多个响应式属性会触发更新周期，重新渲染组件。 Styles. 组件可以定义封装样式来控制自己的外观。 Lifecycle. Lit定义了一组回调函数，您可以覆盖这些回调以挂载到组件的生命周期。例如，元素添加到页面、组件更新都会运行这些回调。 Tip: 装饰器是一项提议的 JavaScript 功能，因此需要使用 Babel 或 TypeScript 之类的编译器来使用装饰器。 1234567891011121314151617181920212223242526272829import {LitElement, css, html} from 'lit';import {customElement, property} from 'lit/decorators.js';@customElement('simple-greeting')export class SimpleGreeting extends LitElement { // Define scoped styles right with your component, in plain CSS static styles = css` :host { color: blue; } `; // Declare reactive properties @property() name?: string = 'World'; // Render the UI as a function of component state render() { return html` &lt;p&gt;Hello, ${this.name}!&lt;/p&gt; &lt;p&gt;&lt;button @click=&quot;${this._increment}&quot;&gt;Click Me!&lt;/button&gt;&lt;/p&gt; `; } // click 事件回调 @eventOptions() private _increment(e: Event) { this.count++; }} 上面是使用Lit声明的自定义元素，与原生的web components 相比，render、响应式属性等功能，把我们从手写原生js的泥沼中拉了出来。毕竟习惯使用vue, react等声明式框架写ui后，重新回到写类似写jQuery(命令式框架)或原生js的时代，一时会有点很难适应。 Events除了标准的 addEventListener API 之外，Lit 还引入了一种声明式的方式来添加事件监听器。 Lit 使用@eventOptions 装饰器在侦听器上(_handleTouchStart)指定事件选项，传递给@eventOptions 的对象作为选项参数传递给addEventListener。参考上一个例子 首先看一下使用原生web components添加自定义事件： 1234567891011121314151617constructor(){ super(); this._shadowRoot = this.attachShadow({mode: 'open'}); this.checkEvent = new CustomEvent(&quot;check&quot;, { bubbles: true, cancelable: false, composed: true, }); }connectedCallback(){ ... this.shadowRoot.addEventListener(&quot;check&quot;, function (e) { console.log('listend to check event'); console.log(e); }); } Lit 12const event = new Event('my-event', {bubbles: true, composed: true}); // 也可以使用CustomEventmyElement.dispatchEvent(event); 那么事件在Shadow DOM中是如何工作的呢？ 使用 shadow DOM 时，需要对标准事件系统进行一些重要的修改。默认情况下，shadow dom内的事件调度在shadow dom外是不可见的。为了能够在外部触发事件，需要设置eventOptions的composed为true，同时event 的 target 指向lit 组件本身，而不是其shadow dom中的子元素。当然，如果需要获取事件的具体target，可以使用event.composedPath() API， 这个方法返回事件调度遍历的所有节点的数组，包括shadow DOM中的节点。 Lifecycle 生命周期 Lit Web components connectedCallback 当Lit组件连接到文档的 DOM 时，将会初始化第一个元素更新周期；在准备渲染时，Lit 还要确保创建了 renderRoot（通常是它的 shadowRoot）。 当自定义元素第一次被连接到文档DOM时被调用。 disconnectedCallback 暂停reactive update cycle。重连后恢复 当自定义元素与文档DOM断开连接时被调用。 adoptedCallback Lit 对此回调没有默认行为。 当自定义元素被移动到新文档时被调用。 attributeChangedCallback Lit 使用此回调将属性attribute的更改同步到reactive properties。Lit 还会自动设置元素的observedAttributes 数组以匹配组件的reactive properties列表。 当自定义元素的一个属性被增加、移除或更改时被调用。 除了标准的自定义元素生命周期之外，Lit 组件还实现了reactive update cycle。当响应属性更改或显式调用 requestUpdate() 方法时，将触发响应更新周期。更新发生在微任务时间，这意味着它们发生在浏览器将下一帧绘制到屏幕之前。 概括地说，reactive update cycle是： 当一个或多个属性更改或调用 requestUpdate() 时会安排触发更新； 在绘制下一帧之前执行更新：设置反射属性 和 调用组件的 render 方法来更新其内部 DOM； The update is completed and the updateComplete promise is resolved. 由于更新是异步执行的，因此在执行更新之前发生的任何和所有更改都只会导致一次更新。 React 与 Web components React and Web Components are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data. The two goals are complementary. As a developer, you are free to use React in your Web Components, or to use Web Components in React, or both. Vue 与 Web components 我们认为 Vue 和 Web Components 大体上是互补的技术。Vue 能很好地解析和创建自定义元素。不论是在将自定义元素整合到已有的 Vue 应用中，还是使用 Vue 构建和分发自定义元素，你都能获得很好的支持。 参考资料： 【1】https://www.zhangxinxu.com/wordpress/2021/02/css-part-shadow-dom/ 【2】https://developer.mozilla.org/zh-CN/docs/Web/Web_Components 【3】https://lit.dev/docs/ 【4】https://www.html5rocks.com/zh/tutorials/webcomponents/shadowdom-201/ 【5】https://custom-elements-everywhere.com/","link":"/blog/%E5%89%8D%E7%AB%AF/lit%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"},{"title":"","text":"记录一次线上问题排查(css相关)故障重现： 123456789.wrapper { overflow: auto; position: relative;}.absolute { position: absolute; top: -30px; left: 50%;} 解决方法：overflow: auto; 原因分析： 首先，absolute元素是相对于它最近的relative祖先元素进行定位，如果relative元素的overflow 为 auto，那么溢出来的元素会被隐藏； 其次，这里的场景就是要把absolute元素放在超出父元素外的位置，那么就不能使用overflow: auto;。 最后，在实际的场景中，wrapper元素本身就不希望滚动，在排查另外一个滚动条相关的样式问题时，加了这个属性，导致absolute元素看不到。","link":"/blog/uncategorized/"},{"title":"Nginx知识储备","text":"location 匹配顺序= 开头表示精确匹配 ,如 location = / {} 中只匹配根目录结尾的请求，后面不能带任何字符串; ^~ 开头表示uri以某个常规字符串开头，不是正则匹配; &lt;匹配符合以后，停止往下搜索正则，采用这一条&gt;f ~ 开头表示区分大小写的正则匹配; ~* 开头表示不区分大小写的正则匹配; / 通用匹配, 如果没有其它匹配,任何请求都会匹配到; 12345678910111213正则location和普通location正则location “~”和“~*”：“~”表示区分大小写；“~*”表示不区分大小写普通location: 除了上面其余全是(包括没有前缀) “=”，“^~”，“@”“^~”中的“^”表示非，“~”表示正则，意思为不要继续匹配正则“=”也表示阻止正则location，和“^~”的区别为：“^~”依然遵守“最大前缀”匹配；而“=”必须是严格匹配。“@ ”是用来定义“Named Location ”的（可以理解为独立于“普通location”和“正则location”之外的第三种类型），这种“Named Location ”不是用来处理普通的HTTP 请求的，它是专门用来处理“内部重定向（internally redirected ）”请求的。注意：这里说的“内部重定向（internally redirected ）”是不需要跟浏览器交互的，纯粹是服务端的一个转发行为。 1231.匹配的顺序是先匹配普通字符串，然后再匹配正则表达式。另外普通字符串匹配顺序是根据配置中字符长度从长到短，也就是说使用普通字符串配置的location顺序是无关紧要的，反正最后nginx会根据配置的长短来进行匹配，但是需要注意的是正则表达式按照配置文件里的顺序测试。找到第一个匹配的正则表达式将停止搜索。2.一般情况下，匹配成功了普通字符串location后还会进行正则表达式location匹配。有两种方法改变这种行为，其一就是使用“=”前缀，这时执行的是严格匹配，并且匹配成功后立即停止其他匹配，同时处理这个请求；另外一种就是使用“^~”前缀，如果把这个前缀用于一个常规字符串那么告诉nginx 如果路径匹配那么不测试正则表达式。 1231.nginx匹配顺序是先匹配普通location，在匹配正则location；2.普通匹配规则无顺序无论写在配置文件的那个地方都一样，但是正则匹配则是按照匹配配置文件中由上到下的先后顺序匹配； 优先级1(location `=` ) &gt; (location `完整路径` ) &gt; (location `^~` 路径) &gt; (location `~`,`~*` 从上向下正则顺序，匹配在最后一条终止) &gt; (location 部分起始路径) &gt; (`/`) 正则表达式匹配，其中： ~ 为区分大小写匹配 ~* 为不区分大小写匹配 !和!*分别为区分大小写不匹配及不区分大小写不匹配 文件及目录匹配，其中： -f和!-f用来判断是否存在文件 -d和!-d用来判断是否存在目录 -e和!-e用来判断是否存在文件或目录 -x和!-x用来判断文件是否可执行 flag标记有： last 相当于Apache里的[L]标记，表示完成rewrite break 终止匹配, 不再匹配后面的规则 redirect 返回302临时重定向 地址栏会显示跳转后的地址 permanent 返回301永久重定向 地址栏会显示跳转后的地址 全局变量$args, 请求中的参数;$content_length, HTTP请求信息里的”Content-Length”;$content_type, 请求信息里的”Content-Type”;$document_root, 针对当前请求的根路径设置值;$document_uri, 与$uri相同;$host, 请求信息中的”Host”，如果请求中没有Host行，则等于设置的服务器名;$limit_rate, 对连接速率的限制;$request_method, 请求的方法，比如”GET”、”POST”等;$remote_addr, 客户端地址;$remote_port, 客户端端口号;$remote_user, 客户端用户名，认证用;$request_filename, 当前请求的文件路径名$request_body_file$request_uri, 请求的URI，带查询字符串;$query_string, 与$args相同;$scheme, 所用的协议，比如http或者是https，比如rewrite ^(.+)$ $scheme://example.com$1 redirect;$server_protocol, 请求的协议版本，”HTTP/1.0”或”HTTP/1.1”;$server_addr, 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费);$server_name, 请求到达的服务器名;$server_port, 请求到达的服务器端口号;$uri, 请求的URI，可能和最初的值有不同，比如经过重定向之类的。","link":"/blog/uncategorized/nginx%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"},{"title":"记录一次线上问题排查(css相关)","text":"故障重现： 123456789.wrapper { overflow: auto; position: relative;}.absolute { position: absolute; top: -30px; left: 50%;} 解决方法：overflow: auto; 原因分析： 首先，absolute元素是相对于它最近的relative祖先元素进行定位，如果relative元素的overflow 为 auto，那么溢出来的元素会被隐藏； 其次，这里的场景就是要把absolute元素放在超出父元素外的位置，那么就不能使用overflow: auto;。 最后，在实际的场景中，wrapper元素本身就不希望滚动，在排查另外一个滚动条相关的样式问题时，加了这个属性，导致absolute元素看不到。","link":"/blog/uncategorized/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-css%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"web components","slug":"web-components","link":"/blog/tags/web-components/"},{"name":"Lit","slug":"Lit","link":"/blog/tags/Lit/"},{"name":"graphql","slug":"graphql","link":"/blog/tags/graphql/"}],"categories":[{"name":"前端","slug":"前端","link":"/blog/categories/%E5%89%8D%E7%AB%AF/"}]}